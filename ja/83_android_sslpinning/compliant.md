
証明書の固定は、次の2つのオプションで行うことができます。

1.証明書をピン留めする
2.公開鍵をピン留めする

公開鍵を選択した場合は、さらに2つの選択肢があります。

- `subjectPublicKeyInfo`をピン留めする
- `RSAPublicKey`や` DSAPublicKey`のような具象型の1つをピン留めする
n
3つの選択肢について、以下でより詳細に説明します。subjectPublicKeyInfo には公開パラメータ（RSA公開鍵の場合は{e、n}など）とアルゴリズムやOIDなどのコンテキスト情報が含まれているため、subjectPublicKeyInfo をピン留めすることをおすすめします。
コンテキストは時々ベアリングを保持するのに役立ち、右側の図は利用可能な追加情報を示します。

### 証明書

証明書はピン留めするのが最も簡単です。 ウェブサイトの帯域外の証明書を取得し、IT担当者に会社の証明書を電子メールで送信し、openssl s_client を使用して証明書を取得させることができます。実行時に、コールバックでWebサイトまたはサーバーの証明書を取得します。コールバック内で、取得した証明書をプログラム内に埋め込まれた証明書と比較します。 比較が失敗した場合は、メソッドまたは関数に失敗します。証明書を固定することには欠点があります。 サイトが定期的に証明書を更新する場合、アプリケーションを定期的に更新する必要があります。たとえば、Googleは証明書をローテーションするため、アプリケーションをGoogleサービスに依存する場合は、月に1回更新する必要があります。Googleが証明書をローテーションしても、（証明書内の）基盤となる公開鍵は静的なままです。

### 公開鍵

公開鍵のピン留めはより柔軟なものですが、証明書から公開鍵を抽出するために必要な手順があるため少し複雑です。証明書と同様に、プログラムは抽出された公開鍵を公開鍵の埋め込みコピーでチェックします。公開鍵のピン割り当てには2つの弱点があります。まず第一に、証明書からキーを抽出する必要があるため、キー（証明書と比較して）を扱うのは難しく、抽出はJavaと.Netではちいさな不都合程度ですが、Cocoa / CocoaTouchとOpenSSLでは非常にやっかいです。第2に、キーは静的であり、キーローテーションポリシーに違反する可能性があります。

### ハッシング

上記の3つの選択肢は DER エンコーディングを使用していましたが、情報のハッシュを使用することも許容されています。実際、元のサンプルプログラムは、ダイジェストの証明書と公開鍵を使用して書かれていました。サンプルは、プログラマがdumpasn1や他のASN.1デコーダのようなツールを使ってオブジェクトを検査できるように変更されました。
ハッシングにはさらに3つの利点があります。 まず第一に、ハッシングを使用すると、証明書または公開鍵の匿名化が可能になります。 これは、デコンパイルとリエンジニアリングの際に情報漏洩が懸念されるアプリケーションにとって重要なことです。 第2に、ダイジェスト証明書のフィンガープリントは、多くのライブラリのネイティブAPIとして利用できることが多く、利便性も高いです。 最後に、組織は、プライマリアイデンティティが侵害された場合に備えて予備（またはバックアップ）アイデンティティを供給したいと考えるかもしれません。 ハッシングは、あなたの敵が使用前に予約証明書または公開鍵を見ないようにします。 実際には、GoogleのIETF草案であるwebsec-key-pinningはこの手法を使用しています。

